// Via Labs V4 Message Gateway - Event Decoders
import { base58Encode, readU128LE, readVecU8, getChainName } from "./utils";

// Event discriminators (8 bytes each) - these would be generated by Anchor
export const EVENT_DISCRIMINATORS = {
  send_requested: "d918849a046c777a",
  tx_pda_created: "7c5c5b3bb0d17af1",
  message_processed: "3d2b1c5a9a8b7f6e",
  system_status_changed: "1a2b3c4d5e6f7a8b",
};

// Reverse lookup for discriminator to event name
export const DISCRIMINATOR_TO_EVENT: Record<string, string> = {};
for (const [name, disc] of Object.entries(EVENT_DISCRIMINATORS)) {
  DISCRIMINATOR_TO_EVENT[disc] = name;
}

// Type definitions for decoded events
export interface SendRequestedDecoded {
  event: "send_requested";
  txId: string;
  sender: string;
  recipient: string;
  recipientLength: number;
  destChainId: string;
  destChainName: string;
  chainData: string;
  chainDataHex: string;
  confirmations: number;
}

export interface TxPdaCreatedDecoded {
  event: "tx_pda_created";
  txId: string;
  sourceChainId: string;
  sourceChainName: string;
}

export interface MessageProcessedDecoded {
  event: "message_processed";
  txId: string;
  sourceChainId: string;
  sourceChainName: string;
  relayer: string;
}

export interface SystemStatusChangedDecoded {
  event: "system_status_changed";
  enabled: boolean;
}

export interface UnknownEventDecoded {
  event: "unknown";
  discriminator: string;
  rawHex: string;
}

export interface EventErrorDecoded {
  event: string;
  error: string;
  discriminator: string;
  rawHex: string;
}

export type DecodedEvent =
  | SendRequestedDecoded
  | TxPdaCreatedDecoded
  | MessageProcessedDecoded
  | SystemStatusChangedDecoded
  | UnknownEventDecoded
  | EventErrorDecoded;

function decodeSendRequested(buffer: Buffer): SendRequestedDecoded {
  let offset = 8; // Skip discriminator

  // tx_id: u128
  const txId = readU128LE(buffer, offset);
  offset += 16;

  // sender: [u8; 32] (fixed array)
  const sender = buffer.subarray(offset, offset + 32);
  offset += 32;

  // recipient: Vec<u8>
  const recipient = readVecU8(buffer, offset);
  offset = recipient.nextOffset;

  // dest_chain_id: u64
  const destChainId = buffer.readBigUInt64LE(offset);
  offset += 8;

  // chain_data: Vec<u8>
  const chainData = readVecU8(buffer, offset);
  offset = chainData.nextOffset;

  // confirmations: u16
  const confirmations = buffer.readUInt16LE(offset);
  offset += 2;

  return {
    event: "send_requested",
    txId: txId.toString(),
    sender: base58Encode(sender),
    recipient:
      recipient.length === 32
        ? base58Encode(recipient.data)
        : recipient.data.toString("hex"),
    recipientLength: recipient.length,
    destChainId: destChainId.toString(),
    destChainName: getChainName(destChainId),
    chainData: chainData.data.toString("utf8"),
    chainDataHex: chainData.data.toString("hex"),
    confirmations,
  };
}

function decodeTxPdaCreated(buffer: Buffer): TxPdaCreatedDecoded {
  let offset = 8; // Skip discriminator

  // tx_id: u128
  const txId = readU128LE(buffer, offset);
  offset += 16;

  // source_chain_id: u64
  const sourceChainId = buffer.readBigUInt64LE(offset);
  offset += 8;

  return {
    event: "tx_pda_created",
    txId: txId.toString(),
    sourceChainId: sourceChainId.toString(),
    sourceChainName: getChainName(sourceChainId),
  };
}

function decodeMessageProcessed(buffer: Buffer): MessageProcessedDecoded {
  let offset = 8; // Skip discriminator

  // tx_id: u128
  const txId = readU128LE(buffer, offset);
  offset += 16;

  // source_chain_id: u64
  const sourceChainId = buffer.readBigUInt64LE(offset);
  offset += 8;

  // relayer: Pubkey (32 bytes)
  const relayer = buffer.subarray(offset, offset + 32);
  offset += 32;

  return {
    event: "message_processed",
    txId: txId.toString(),
    sourceChainId: sourceChainId.toString(),
    sourceChainName: getChainName(sourceChainId),
    relayer: base58Encode(relayer),
  };
}

function decodeSystemStatusChanged(buffer: Buffer): SystemStatusChangedDecoded {
  let offset = 8; // Skip discriminator

  // enabled: bool
  const enabled = buffer[offset] !== 0;
  offset += 1;

  return {
    event: "system_status_changed",
    enabled,
  };
}

// Main event decoder function
export function decodeEvent(base64Data: string): DecodedEvent {
  const buffer = Buffer.from(base64Data, "base64");

  if (buffer.length < 8) {
    throw new Error("Buffer too small for event discriminator");
  }

  const discriminator = buffer.subarray(0, 8).toString("hex");

  // Try to match known discriminators, but also handle the send_requested case we know works
  let eventName = DISCRIMINATOR_TO_EVENT[discriminator];

  // Special handling for send_requested since we know its discriminator
  if (discriminator === "d918849a046c777a") {
    eventName = "send_requested";
  }

  if (!eventName) {
    return {
      event: "unknown",
      discriminator,
      rawHex: buffer.toString("hex"),
    };
  }

  try {
    switch (eventName) {
      case "send_requested":
        return decodeSendRequested(buffer);
      case "tx_pda_created":
        return decodeTxPdaCreated(buffer);
      case "message_processed":
        return decodeMessageProcessed(buffer);
      case "system_status_changed":
        return decodeSystemStatusChanged(buffer);
      default:
        throw new Error(`Decoder not implemented for ${eventName}`);
    }
  } catch (error) {
    return {
      event: eventName,
      error: (error as Error).message,
      discriminator,
      rawHex: buffer.toString("hex"),
    };
  }
}

// Utility function to detect if data is likely an event vs instruction
export function isLikelyEvent(base64Data: string): boolean {
  const buffer = Buffer.from(base64Data, "base64");
  const discriminator = buffer.subarray(0, 8).toString("hex");

  // Known event discriminators
  if (Object.values(EVENT_DISCRIMINATORS).includes(discriminator)) {
    return true;
  }

  // Known send_requested discriminator
  if (discriminator === "d918849a046c777a") {
    return true;
  }

  return false;
}
